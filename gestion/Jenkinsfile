// gestion/Jenkinsfile
// --- CÓDIGO COMPLETAMENTE CORREGIDO ---

pipeline {
    agent any

    environment {
        // --- Variables Globales ---
        // ¡CORRECCIÓN! Se han quitado TODOS los comandos 'sh "aws..."' de aquí.
        // Solo dejamos variables estáticas.
        AWS_REGION                 = "us-east-1"
        ECS_CLUSTER_NAME           = "proyecto-cluster"
        ECS_SERVICE_NAME           = "proyecto-servicio" // El servicio que crearemos
        ECS_TASK_FAMILY            = "proyecto-gestion-task"
        // Tag único para la imagen
        IMAGE_TAG                  = "build-${env.BUILD_NUMBER}"
    }

    stages {

     // --- Etapa 1: Ejecutar Terraform (Crear el Clúster) ---
        stage('Automatizar Creación de Infra (Terraform)') {
            when {
                expression { params.RUN_TERRAFORM }
            }
            steps {
                // --- ¡ESTA ES LA LÍNEA CORREGIDA! ---
                dir('gestion/infra_aws') { 
                    withAWS(credentials: 'aws-credentials-jenkins', region: env.AWS_REGION) {
                        withCredentials([string(credentialsId: 'rds-db-password', variable: 'DB_PASS_SECRET')]) {
                            sh 'terraform init'
                            sh "terraform apply -auto-approve -var 'db_password=${DB_PASS_SECRET}'"
                        }
                    }
                }
            }
        }

        // --- Etapa 2: Crear el Servicio ECS (Primera Vez) ---
       script {
                        // Obtenemos las variables dinámicas DENTRO del bloque withAWS
                        def awsAccountId = sh(returnStdout: true, script: 'aws sts get-caller-identity --query Account --output text').trim()
                        def ecsTaskRoleArn = "arn:aws:iam::${awsAccountId}:role/proyecto-ecs-task-execution-role"
                        def subnets = sh(returnStdout: true, script: "aws ec2 describe-subnets --filters 'Name=tag:Name,Values=proyecto-public-*' --query 'Subnets[*].SubnetId' --output json").trim()
                        def sg = sh(returnStdout: true, script: "aws ec2 describe-security-groups --filters 'Name=group-name,Values=proyecto-ecs-sg' --query 'SecurityGroups[0].GroupId' --output text").trim()
                        def tg_arn = sh(returnStdout: true, script: "aws elbv2 describe-target-groups --names proyecto-alb-tg --query 'TargetGroups[0].TargetGroupArn' --output text").trim()

                        // --- INICIO DE LA CORRECCIÓN ---

                        // 1. Definimos un "dummy" JSON que tenga un 'containerName=web' y 'containerPort=80'
                        //    para que coincida con el load balancer. Usamos una imagen 'nginx' simple.
                        def dummyTaskJson = """
                        {
                            "family": "${ECS_TASK_FAMILY}",
                            "executionRoleArn": "${ecsTaskRoleArn}",
                            "networkMode": "awsvpc",
                            "cpu": "256",
                            "memory": "512",
                            "requiresCompatibilities": ["FARGATE"],
                            "containerDefinitions": [
                                {
                                    "name": "web",
                                    "image": "nginx:alpine",
                                    "essential": true,
                                    "portMappings": [
                                        {
                                            "containerPort": 80,
                                            "protocol": "tcp"
                                        }
                                    ]
                                }
                            ]
                        }
                        """
                        writeFile file: 'dummy-task.json', text: dummyTaskJson

                        // 2. Registramos la task-definition "dummy" Y CAPTURAMOS LA REVISIÓN
                        def dummyTaskRevision = sh(returnStdout: true, script: """
                            aws ecs register-task-definition --cli-input-json file://dummy-task.json \
                            --query 'taskDefinition.taskDefinitionArn' --output text
                        """).trim()

                        // 3. Ahora creamos el servicio (esto SÍ funcionará)
                        sh """
                            aws ecs create-service --cluster ${ECS_CLUSTER_NAME} \
                            --service-name ${ECS_SERVICE_NAME} \
                            --task-definition ${dummyTaskRevision} \
                            --launch-type FARGATE \
                            --desired-count 1 \
                            --network-configuration "awsvpcConfiguration={subnets=${subnets},securityGroups=[${sg}],assignPublicIp=ENABLED}" \
                            --load-balancers "targetGroupArn=${tg_arn},containerName=web,containerPort=80"
                        """
                        // --- FIN DE LA CORRECCIÓN ---
                    }
        // --- Etapa 3: Build de la Aplicación Laravel ---
        stage('Build Docker App (Laravel)') {
            steps {
                dir('gestion') { 
                    withAWS(credentials: 'aws-credentials-jenkins', region: env.AWS_REGION) {
                        script {
                            // --- CORRECCIÓN ---
                            // Obtenemos el ID de cuenta aquí para ECR
                            def awsAccountId = sh(returnStdout: true, script: 'aws sts get-caller-identity --query Account --output text').trim()
                            def ecrAppRepoUrl = "${awsAccountId}.dkr.ecr.${AWS_REGION}.amazonaws.com/proyecto-gestion-app"

                            // Hacemos login en ECR
                            sh "aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${awsAccountId}.dkr.ecr.${AWS_REGION}.amazonaws.com"
                            
                            // Construimos la imagen de la app
                            sh "docker build -t ${ecrAppRepoUrl}:${IMAGE_TAG} -f Dockerfile ."
                            
                            // Subimos la imagen de la app
                            sh "docker push ${ecrAppRepoUrl}:${IMAGE_TAG}"
                        }
                    }
                }
            }
        }

        // --- Etapa 4: Build del Servidor Web (Nginx) ---
        stage('Build Docker Web (Nginx)') {
            steps {
                withAWS(credentials: 'aws-credentials-jenkins', region: env.AWS_REGION) {
                    script {
                        // --- CORRECCIÓN ---
                        // Obtenemos el ID de cuenta aquí para ECR
                        def awsAccountId = sh(returnStdout: true, script: 'aws sts get-caller-identity --query Account --output text').trim()
                        def ecrWebRepoUrl = "${awsAccountId}.dkr.ecr.${AWS_REGION}.amazonaws.com/proyecto-gestion-web"
                        
                        // Creamos un Dockerfile temporal para Nginx
                        writeFile file: 'Dockerfile.nginx', text: """
                            FROM nginx:1.25-alpine
                            # Asegúrate de que tu archivo se llama 'nginx.conf'
                            COPY gestion/docker/nginx.conf /etc/nginx/conf.d/default.conf
                        """
                        
                        sh "aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${awsAccountId}.dkr.ecr.${AWS_REGION}.amazonaws.com"
                        
                        // Construimos la imagen de Nginx
                        sh "docker build -t ${ecrWebRepoUrl}:${IMAGE_TAG} -f Dockerfile.nginx ."
                        
                        // Subimos la imagen de Nginx
                        sh "docker push ${ecrWebRepoUrl}:${IMAGE_TAG}"
                    }
                }
            }
        }
        
        // --- Etapa 5: Desplegar en ECS (Actualizar Servicio) ---
        stage('Deploy to ECS') {
            steps {
                dir('gestion') { 
                    withAWS(credentials: 'aws-credentials-jenkins', region: env.AWS_REGION) {
                        script { 
                            withCredentials([string(credentialsId: 'rds-db-password', variable: 'DB_PASS_SECRET')]) {
                        
                                // --- CORRECCIÓN ---
                                // Obtenemos TODAS las variables dinámicas de AWS aquí
                                def awsAccountId = sh(returnStdout: true, script: 'aws sts get-caller-identity --query Account --output text').trim()
                                def ecrAppRepoUrl = "${awsAccountId}.dkr.ecr.${AWS_REGION}.amazonaws.com/proyecto-gestion-app"
                                def ecrWebRepoUrl = "${awsAccountId}.dkr.ecr.${AWS_REGION}.amazonaws.com/proyecto-gestion-web"
                                def ecsTaskRoleArn = "arn:aws:iam::${awsAccountId}:role/proyecto-ecs-task-execution-role"
                                def albDnsName = sh(returnStdout: true, script: "aws elbv2 describe-load-balancers --names proyecto-alb --query 'LoadBalancers[0].DNSName' --output text").trim()
                                def dbEndpoint = sh(returnStdout: true, script: "aws rds describe-db-instances --db-instance-identifier-prefix proyecto-db --query 'DBInstances[0].Endpoint.Address' --output text").trim()

                                // 1. Rellenamos la plantilla JSON
                                def taskTemplate = readFile('task-definition-template.json')
                                def taskDef = taskTemplate
                                    .replace('${ECS_TASK_EXECUTION_ROLE_ARN}', ecsTaskRoleArn)
                                    .replace('${ECR_APP_REPO_URL}', ecrAppRepoUrl)
                                    .replace('${ECR_WEB_REPO_URL}', ecrWebRepoUrl)
                                    .replace('${IMAGE_TAG}', env.IMAGE_TAG)
                                    .replace('${ALB_DNS_NAME}', albDnsName)
                                    .replace('${DB_ENDPOINT}', dbEndpoint)
                                    .replace('${DB_PASSWORD}', DB_PASS_SECRET)

                                writeFile file: 'new-task-def.json', text: taskDef
                                
                                // 2. Registramos la nueva Task Definition
                                def taskRevision = sh(returnStdout: true, script: "aws ecs register-task-definition --cli-input-json file://new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text").trim()
                                
                                echo "Nueva Task Definition registrada: ${taskRevision}"

                                // 3. Actualizamos el servicio
                                sh "aws ecs update-service --cluster ${ECS_CLUSTER_NAME} --service ${ECS_SERVICE_NAME} --task-definition ${taskRevision} --force-new-deployment"
                                
                                echo "¡Despliegue iniciado en ECS!"

                                // 4. Ejecutar migraciones
                                echo "Ejecutando migraciones..."
                                sh """
                                   aws ecs run-task --cluster ${ECS_CLUSTER_NAME} \
                                   --task-definition ${taskRevision} \
                                   --launch-type FARGATE \
                                   --network-configuration "awsvpcConfiguration={subnets=[${sh(returnStdout: true, script: "aws ec2 describe-subnets --filters 'Name=tag:Name,Values=proyecto-public-a' --query 'Subnets[0].SubnetId' --output text").trim()}],securityGroups=[${sh(returnStdout: true, script: "aws ec2 describe-security-groups --filters 'Name=tag:Name,Values=proyecto-ecs-sg' --query 'SecurityGroups[0].GroupId' --output text").trim()}]}" \
                                   --overrides '{"containerOverrides":[{"name":"app","command":["php","artisan","migrate","--force"]}]}'
                                """
                            }
                        } 
                    }
                }
            }
        }
    }
}